[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Start here",
    "section": "",
    "text": "In Julia, type\n] add https://github.com/JuliaTDA/TDAmapper.jl https://github.com/JuliaTDA/GeometricDatasets.jl\nThe ] character mark the command to be executed in Julia package mode."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Start here",
    "section": "",
    "text": "In Julia, type\n] add https://github.com/JuliaTDA/TDAmapper.jl https://github.com/JuliaTDA/GeometricDatasets.jl\nThe ] character mark the command to be executed in Julia package mode."
  },
  {
    "objectID": "index.html#first-usage",
    "href": "index.html#first-usage",
    "title": "Start here",
    "section": "First usage",
    "text": "First usage\nLoad the packages\n\nusing TDAmapper;\nimport GeometricDatasets as gd;\n\ncreate a torus\n\nX = gd.torus(2000)\n\n3×2000 Matrix{Float64}:\n -2.17768    1.35623   -0.0562065  …   0.906515  -1.53537   -2.11367\n  3.34555   -2.3255     2.30534        2.2027    -1.38697   -1.66377\n -0.127294   0.951413  -0.719997      -0.786131  -0.365191   0.950715\n\n\ndefine the filter values\n\nfv = X[1, :];\n\nand the covering\n\nC = uniform(fv, overlap = 150);\n\nCalculate the mapper\n\nmp = mapper(X, fv, C; clustering = cluster_dbscan(;radius = 1))\n\nand plot the results\n\nnode_values = node_colors(mp, fv)\n\nmapper_plot(mp, node_values = node_values)"
  },
  {
    "objectID": "index.html#new-to-julia",
    "href": "index.html#new-to-julia",
    "title": "Start here",
    "section": "New to Julia?",
    "text": "New to Julia?\nThat was too much Julia for you? No problem! You can learn more with some very nice books like these:\n\nJulia for Optimization and Learning"
  },
  {
    "objectID": "mapper.html",
    "href": "mapper.html",
    "title": "(Classical) mapper",
    "section": "",
    "text": "In topology, there are many ways by which we try to see what can’t be seen, in particular high-dimensional sets. The Reeb graph is one of those ways: given a topological space \\(X\\) and a continuous function \\(f: X \\to \\mathbb{R}\\), we can collapse the connected components of its pre-images to get a graph that reflects the level-sets of \\(f\\).\nMore formally, we define a relation \\(\\sim\\) on \\(X\\) such that \\(p \\sim q\\) if-and-only-if \\(p\\) and \\(q\\) belong to the same connected component of \\(f^{-1}(c)\\) for some \\(c \\in \\mathbb{R}\\).\n\n\n\nThe Reeb graph of a torus using the projection on the z-axis.\n\n\n\n\n\nThe (classical) mapper is an algorithm to create graphs from metric spaces, and can be seen as an “statistical” version of the Reeb graph.\nTo be able to mimick the Reeb graph, we need to change some objects from the continuous setting to the discrete setting:\n\n\\(X = (X, d)\\) is now a finite metric space, also called a point cloud;\n\\(f: X \\to \\mathbb{R}\\) can be any function (since \\(X\\) is discrete, \\(f\\) is automatically continuous);\ninstead of inverse images of points of \\(\\mathbb{R}\\), we calculate inverse images of subsets of \\(\\mathbb{R}\\) (usually intervals);\ninstead of connected components (which are trivial in the discrete setting), we use some clustering algorithm (DBSCAN, single linkage, etc.) and consider these clusterings as “connected pieces of \\(X\\)”.\n\n\nThe mapper graph can shed light to the geometry of \\(X\\):\n\nnodes are clusters of points of \\(X\\);\nthe color of the nodes can summarise some information about the points of \\(X\\) that represent this node;\nedges denote some proximity (in the metric of \\(d\\) of \\(X\\)) between the nodes.\n\nTo be more precise, to calculate the mapper of a metric space \\(X\\), we need the following ingredients:\n\na function \\(f: X \\to \\mathbb{R}\\) that measures something interesting in \\(X\\), as, for example, the excentricity, the first coordinate of PCA, and so on;\na covering \\(C\\) of the image \\(f(X) \\subset \\mathbb{R}\\);\na method \\(l\\) to cluster each \\(f^{-1}(c)\\) for \\(c \\in C\\).\n\nWhen all of this is chosen, we have a covering of \\(X\\) by clustering each pre-image of the elements of \\(C\\), that is:\n\\[\nV = \\{ l(p); \\; p = f^{-1}(c) \\; \\text{for} \\; c \\in C\\}\n\\]\nWe then calculate the 1-dimensional nerve of \\(V\\): we define the set of edges \\(E \\subset V \\times V\\) by\n\\[\n(v_1, v_2) \\in E \\leftrightarrow v_1 \\cap v_2 \\neq \\emptyset\n\\]\nIn words, we have an edge between \\(v_1\\) and \\(v_2\\) if there is some point in both \\(v_1\\) and \\(v_2\\) at the same time."
  },
  {
    "objectID": "mapper.html#some-theory",
    "href": "mapper.html#some-theory",
    "title": "(Classical) mapper",
    "section": "",
    "text": "In topology, there are many ways by which we try to see what can’t be seen, in particular high-dimensional sets. The Reeb graph is one of those ways: given a topological space \\(X\\) and a continuous function \\(f: X \\to \\mathbb{R}\\), we can collapse the connected components of its pre-images to get a graph that reflects the level-sets of \\(f\\).\nMore formally, we define a relation \\(\\sim\\) on \\(X\\) such that \\(p \\sim q\\) if-and-only-if \\(p\\) and \\(q\\) belong to the same connected component of \\(f^{-1}(c)\\) for some \\(c \\in \\mathbb{R}\\).\n\n\n\nThe Reeb graph of a torus using the projection on the z-axis.\n\n\n\n\n\nThe (classical) mapper is an algorithm to create graphs from metric spaces, and can be seen as an “statistical” version of the Reeb graph.\nTo be able to mimick the Reeb graph, we need to change some objects from the continuous setting to the discrete setting:\n\n\\(X = (X, d)\\) is now a finite metric space, also called a point cloud;\n\\(f: X \\to \\mathbb{R}\\) can be any function (since \\(X\\) is discrete, \\(f\\) is automatically continuous);\ninstead of inverse images of points of \\(\\mathbb{R}\\), we calculate inverse images of subsets of \\(\\mathbb{R}\\) (usually intervals);\ninstead of connected components (which are trivial in the discrete setting), we use some clustering algorithm (DBSCAN, single linkage, etc.) and consider these clusterings as “connected pieces of \\(X\\)”.\n\n\nThe mapper graph can shed light to the geometry of \\(X\\):\n\nnodes are clusters of points of \\(X\\);\nthe color of the nodes can summarise some information about the points of \\(X\\) that represent this node;\nedges denote some proximity (in the metric of \\(d\\) of \\(X\\)) between the nodes.\n\nTo be more precise, to calculate the mapper of a metric space \\(X\\), we need the following ingredients:\n\na function \\(f: X \\to \\mathbb{R}\\) that measures something interesting in \\(X\\), as, for example, the excentricity, the first coordinate of PCA, and so on;\na covering \\(C\\) of the image \\(f(X) \\subset \\mathbb{R}\\);\na method \\(l\\) to cluster each \\(f^{-1}(c)\\) for \\(c \\in C\\).\n\nWhen all of this is chosen, we have a covering of \\(X\\) by clustering each pre-image of the elements of \\(C\\), that is:\n\\[\nV = \\{ l(p); \\; p = f^{-1}(c) \\; \\text{for} \\; c \\in C\\}\n\\]\nWe then calculate the 1-dimensional nerve of \\(V\\): we define the set of edges \\(E \\subset V \\times V\\) by\n\\[\n(v_1, v_2) \\in E \\leftrightarrow v_1 \\cap v_2 \\neq \\emptyset\n\\]\nIn words, we have an edge between \\(v_1\\) and \\(v_2\\) if there is some point in both \\(v_1\\) and \\(v_2\\) at the same time."
  },
  {
    "objectID": "mapper.html#less-theory-more-julia",
    "href": "mapper.html#less-theory-more-julia",
    "title": "(Classical) mapper",
    "section": "Less theory, more Julia!",
    "text": "Less theory, more Julia!\nLet’s import some packages:\n\nusing TDAmapper;\nimport GeometricDatasets as gd;\n\nand define \\(X\\) as a torus with the usual Euclidean distance\n\nX = gd.torus(2000)\n\n3×2000 Matrix{Float64}:\n  2.18226    3.54087   -0.879014   …   1.97537    0.852017  -2.4232\n  2.84043    0.221704   3.90208       -1.62571   -3.88278    0.85393\n -0.813234  -0.836608  -0.0164606     -0.897172  -0.221497   0.902476\n\n\nImportant: when using TDAmapper, your point cloud must be in column-major order. That is: each point of \\(X\\) must be a column of X, not a row (as is usual with dataframes). This is so because Distances.jl, NearestNeighbors.jl, Clustering.jl and many other packages for calculations with metric spaces use the column-major order for performance reasons.\nWe define the function \\(f: X \\to \\mathbb{R}\\) as the projection on the \\(x\\)-axis because our torus is laying down compared to the one in the Reeb graph example.\nLet fv be a vector such that fv[i] is the \\(x\\)-axis projection of the point \\(x_i\\) of \\(X\\):\n\nfv = X[1, :];\n\nYou can plot \\(X\\) colored by \\(f\\) as follows:\n\nusing CairoMakie;\nscatter(X[1, :], X[2, :], X[3, :], color = fv)\n\n\n\n\nImportant: the plots will be interactive when running in Julia if you change CairoMakie to GLMakie. Give it a try!\nDefine the covering intervals cv as follows:\n\nC = uniform(fv, overlap = 150);\n\nYou can check the first five intervals of this covering:\n\nC[1:5]\n\n5-element Vector{Interval}:\n Interval(-4.6948256f0, -3.6977174f0)\n Interval(-4.1250496f0, -3.1279411f0)\n Interval(-3.5552733f0, -2.5581648f0)\n Interval(-2.985497f0, -1.9883885f0)\n Interval(-2.4157207f0, -1.4186124f0)\n\n\nFor the clustering algorithm we choose the DBSCAN with radius 1:\n\nclustering = cluster_dbscan(radius = 1);\n\nThen the mapper graph of \\(X\\) can be calculated by\n\n# the mapper function needs:\n# X\n# the values of f(X)\n# the covering C\n# the clustering function\nmp = mapper(X, fv, C; clustering = clustering)\n\nAnd plotted with\n\n# define the value of each node as the maximum of\n# values of fv \nnode_values = node_colors(mp, fv)\n\nmapper_plot(mp, node_values = node_values)\n\n\n\n\nCompare it with the Reeb graph from the start. If this isn’t nice, what is?"
  },
  {
    "objectID": "sampling.html",
    "href": "sampling.html",
    "title": "Sampling data",
    "section": "",
    "text": "An ϵ-net is a subset of a point cloud X such that \\[\n\\forall x \\in X, \\exists y \\in Y | d(x, y) &lt;= \\epsilon\n\\]\nthat is: every point \\(x\\) of \\(X\\) is in an ϵ-neighborhood of some point of \\(Y\\).\n\n\n\nusing TDAmapper\nusing Plots\n\nX = rand(2, 10^4)\nϵ = 0.1\nids = epsilon_net(X, ϵ)\nY = X[:, ids]\nscatter(X[1, :], X[2, :])\nscatter!(Y[1, :], Y[2, :], color = :red)\n\nSearching neighborhood of point number 2     Time: 0:00:00Searching neighborhood of point number 78      Time: 0:00:00"
  },
  {
    "objectID": "sampling.html#ϵ-net",
    "href": "sampling.html#ϵ-net",
    "title": "Sampling data",
    "section": "",
    "text": "An ϵ-net is a subset of a point cloud X such that \\[\n\\forall x \\in X, \\exists y \\in Y | d(x, y) &lt;= \\epsilon\n\\]\nthat is: every point \\(x\\) of \\(X\\) is in an ϵ-neighborhood of some point of \\(Y\\).\n\n\n\nusing TDAmapper\nusing Plots\n\nX = rand(2, 10^4)\nϵ = 0.1\nids = epsilon_net(X, ϵ)\nY = X[:, ids]\nscatter(X[1, :], X[2, :])\nscatter!(Y[1, :], Y[2, :], color = :red)\n\nSearching neighborhood of point number 2     Time: 0:00:00Searching neighborhood of point number 78      Time: 0:00:00"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "ballmapper.html",
    "href": "ballmapper.html",
    "title": "Ball mapper",
    "section": "",
    "text": "Another way to reduce the complexity of a metric space is to approximate it by a simplicial complex. Simplicial complexes are like small building blocks glued together, each of these blocks a small representative of an \\(n\\)-dimensional space: points, line segments, triangles, tetrahedrons, and so on.\nThe Vietoris-Rips complex is build as follows: given a metric space \\((X, d)\\) and an \\(\\epsilon &gt; 0\\), define the following simplicial complex:\n\\[\nVR(X, \\epsilon) = \\{ [ x_1, \\ldots, x_n ] \\; d(x_i, x_j) &lt; \\epsilon, \\forall i, j \\}\n\\]\nthat is: the points of \\(X\\) are our vertices, and we have an \\(n\\)-simplex \\([x_1, \\ldots, x_n]\\) whenever the pairwise distance between \\(x_1, \\ldots, x_n\\) is less than \\(\\epsilon\\). This condition is equivalent to ask that\n\\[\n\\cap_i B(x_i, \\epsilon) \\neq \\emptyset\n\\]\nwhere \\(B(x, \\epsilon)\\) is the ball of center \\(x\\) and radius \\(\\epsilon\\).\n\n\n\nThe black dots are points in a metric space; the pink circles are \\(\\epsilon\\) balls around the points; in green, we have the Vietoris-Rips complex. Source: https://www.researchgate.net/publication/331739415_Topological_data_analysis_for_the_string_landscape"
  },
  {
    "objectID": "ballmapper.html#documenting-objects-after-they-are-defined",
    "href": "ballmapper.html#documenting-objects-after-they-are-defined",
    "title": "Ball mapper",
    "section": "Documenting objects after they are defined",
    "text": "Documenting objects after they are defined\nYou can document an object after its definition by\n@doc \"foo\" function_to_doc\n@doc \"bar\" TypeToDoc\nFor macros, the syntax is @doc \"macro doc\" :(@Module.macro) or @doc \"macro doc\" :(string_macro\"\") for string macros. Without the quote :() the expansion of the macro will be documented."
  },
  {
    "objectID": "ballmapper.html#retrieving-documentation",
    "href": "ballmapper.html#retrieving-documentation",
    "title": "Ball mapper",
    "section": "Retrieving Documentation",
    "text": "Retrieving Documentation\nYou can retrieve docs for functions, macros and other objects as follows:\n@doc foo\n@doc @time\n@doc md\"\""
  },
  {
    "objectID": "ballmapper.html#functions-methods",
    "href": "ballmapper.html#functions-methods",
    "title": "Ball mapper",
    "section": "Functions & Methods",
    "text": "Functions & Methods\nPlacing documentation before a method definition (e.g. function foo() ... or foo() = ...) will cause that specific method to be documented, as opposed to the whole function. Method docs are concatenated together in the order they were defined to provide docs for the function."
  },
  {
    "objectID": "ballmapper.html#the-vietoris-rips-complex",
    "href": "ballmapper.html#the-vietoris-rips-complex",
    "title": "Ball mapper",
    "section": "",
    "text": "Another way to reduce the complexity of a metric space is to approximate it by a simplicial complex. Simplicial complexes are like small building blocks glued together, each of these blocks a small representative of an \\(n\\)-dimensional space: points, line segments, triangles, tetrahedrons, and so on.\nThe Vietoris-Rips complex is build as follows: given a metric space \\((X, d)\\) and an \\(\\epsilon &gt; 0\\), define the following simplicial complex:\n\\[\nVR(X, \\epsilon) = \\{ [ x_1, \\ldots, x_n ] \\; d(x_i, x_j) &lt; \\epsilon, \\forall i, j \\}\n\\]\nthat is: the points of \\(X\\) are our vertices, and we have an \\(n\\)-simplex \\([x_1, \\ldots, x_n]\\) whenever the pairwise distance between \\(x_1, \\ldots, x_n\\) is less than \\(\\epsilon\\). This condition is equivalent to ask that\n\\[\n\\cap_i B(x_i, \\epsilon) \\neq \\emptyset\n\\]\nwhere \\(B(x, \\epsilon)\\) is the ball of center \\(x\\) and radius \\(\\epsilon\\).\n\n\n\nThe black dots are points in a metric space; the pink circles are \\(\\epsilon\\) balls around the points; in green, we have the Vietoris-Rips complex. Source: https://www.researchgate.net/publication/331739415_Topological_data_analysis_for_the_string_landscape"
  },
  {
    "objectID": "ballmapper.html#the-ball-mapper",
    "href": "ballmapper.html#the-ball-mapper",
    "title": "Ball mapper",
    "section": "The ball mapper",
    "text": "The ball mapper\nThe ball mapper is clearly inspired by the Vietoris-Rips complex. Given a metric space \\((X, d)\\) with \\(X = \\{x_1, \\ldots, x_n\\}\\), select a subset of indexes \\(L \\subseteq \\{1, \\ldots, n\\}\\) and define the ball mapper graph G as follows: the set of vertices of \\(G\\) is \\(L\\), and set of edges \\(E\\) given by\n\\[\n(i, j) \\in E \\Leftrightarrow B(x_i, \\epsilon) \\cap B(x_j, \\epsilon) \\neq \\emptyset\n\\]\nThe ball mapper then can be seen as the 1-skeleton of the Vietoris-Rips, but create using balls whose center can only be the elements indexed by \\(L\\).\nTo exemplify, consider a circle\n\nusing TDAmapper\nimport GeometricDatasets as gd\n\nX = gd.sphere(1000, dim = 2);\n\nCheck that it is indeed a circle:\n\nusing CairoMakie\nscatter(X)\n\n\n\n\nNow take \\(L\\) as a hundred random points and let’s create the ball mapper of \\(X\\) with radius \\(\\epsilon = 0.1\\):\n\nL = rand(1:1000, 100)\nmp = ball_mapper(X, L, ϵ = 0.5);\n\n\nmapper_plot(mp)\n\n\n\n\nThat’s quite a circle!"
  },
  {
    "objectID": "generalization.html",
    "href": "generalization.html",
    "title": "Generalization",
    "section": "",
    "text": "We can boil down the two mapper algorithms we saw earlier as follows:\n\n(covering step) Given a metric space \\((X, d)\\), create a covering \\(C\\) of \\(X\\);\n(nerve step) Using \\(C\\) as vertex set, create a graph.\n\nIn the classical mapper context, \\(C\\) is generated using the clustering of pre-images of a function \\(f: X \\to \\mathbb{R}\\). In the ball mapper scenario, we cover \\(X\\) using \\(\\epsilon\\)-balls with centers as a subset of \\(X\\).\n\n\nLet \\(X\\), \\(L\\) and \\(\\epsilon\\) be given as in the ball mapper case. For any \\(l \\in L\\), define \\(x_l\\) = X[:, l]. Examples of how to generalize the covering step:\n\nFix \\(n &gt; 0\\) integer. Create a ball \\(B\\) of radius \\(\\epsilon\\) around \\(x_l\\). If \\(B\\) contains less than \\(n\\) elements, then we redefine \\(B\\) as the set of \\(n\\) nearest neighbors of \\(x_l\\).\nFix \\(\\lambda &gt; 0\\). Let \\(d_l\\) be the distance between \\(x_l\\) and its closest point. Create a ball \\(B\\) of radius \\(\\lambda * d_1\\). Proceed like this to create a covering of \\(X\\).\n\n\n\n\nThere are many alternatives to the nerve construction. Let \\(a\\) and \\(b\\) be two elements of a covering \\(C\\). Let \\(G = (V, E)\\) be a graph with vertex-set \\(V = C\\). Examples of how to generalize the nerve step:\n\nFix \\(k &gt; 0\\). Define \\((a, b) \\in E\\) iff \\(|a \\cap b| \\geq k\\), that is: we will only allow intersections with at least \\(k\\) elements. Setting \\(k = 1\\) will give us the usual nerve graph."
  },
  {
    "objectID": "generalization.html#what-is-a-mapper-algorithm",
    "href": "generalization.html#what-is-a-mapper-algorithm",
    "title": "Generalization",
    "section": "",
    "text": "We can boil down the two mapper algorithms we saw earlier as follows:\n\n(covering step) Given a metric space \\((X, d)\\), create a covering \\(C\\) of \\(X\\);\n(nerve step) Using \\(C\\) as vertex set, create a graph.\n\nIn the classical mapper context, \\(C\\) is generated using the clustering of pre-images of a function \\(f: X \\to \\mathbb{R}\\). In the ball mapper scenario, we cover \\(X\\) using \\(\\epsilon\\)-balls with centers as a subset of \\(X\\).\n\n\nLet \\(X\\), \\(L\\) and \\(\\epsilon\\) be given as in the ball mapper case. For any \\(l \\in L\\), define \\(x_l\\) = X[:, l]. Examples of how to generalize the covering step:\n\nFix \\(n &gt; 0\\) integer. Create a ball \\(B\\) of radius \\(\\epsilon\\) around \\(x_l\\). If \\(B\\) contains less than \\(n\\) elements, then we redefine \\(B\\) as the set of \\(n\\) nearest neighbors of \\(x_l\\).\nFix \\(\\lambda &gt; 0\\). Let \\(d_l\\) be the distance between \\(x_l\\) and its closest point. Create a ball \\(B\\) of radius \\(\\lambda * d_1\\). Proceed like this to create a covering of \\(X\\).\n\n\n\n\nThere are many alternatives to the nerve construction. Let \\(a\\) and \\(b\\) be two elements of a covering \\(C\\). Let \\(G = (V, E)\\) be a graph with vertex-set \\(V = C\\). Examples of how to generalize the nerve step:\n\nFix \\(k &gt; 0\\). Define \\((a, b) \\in E\\) iff \\(|a \\cap b| \\geq k\\), that is: we will only allow intersections with at least \\(k\\) elements. Setting \\(k = 1\\) will give us the usual nerve graph."
  },
  {
    "objectID": "generalization.html#creating-my-own-mapper",
    "href": "generalization.html#creating-my-own-mapper",
    "title": "Generalization",
    "section": "Creating my own mapper",
    "text": "Creating my own mapper\nYou can change the 2 steps above within the context of the ball mapper, as can be seen in the docs.\n\n\n\n\n\n\n\n\ndoc\n\n\n\nball_mapper_generic(\n    X::PointCloud, L::Vector{&lt;:Integer}, \n    covering_function::Function,\n    graph_function::Function\n    )\nCreates the ball mapper of a metric space X subsampled by L.\n\nArguments\n\nX::PointCloud: a point cloud.\nL::Vector{&lt;:Integer}: a subset of index of X, that is: L is a subset of [1:size(X)[2]].\ncovering_function::Function: a function that creates a cover for X. Its arguments are X and L.\ngraph_function::Function: a function that creates a graph. It accepts a CoveredPointCloud object.\n\n\n\nDetails\nSee the “Generalization” page of the online documentation."
  },
  {
    "objectID": "examples/diabetes.html",
    "href": "examples/diabetes.html",
    "title": "The Reaven and Miller diabetes dataset",
    "section": "",
    "text": "Let’s reproduce the results of […]."
  },
  {
    "objectID": "examples/diabetes.html#dataset",
    "href": "examples/diabetes.html#dataset",
    "title": "The Reaven and Miller diabetes dataset",
    "section": "Dataset",
    "text": "Dataset\nTo load the dataset, we will use a R package that contains it, and then convert it to a Julia DataFrame. You will need a working R installation for that.\n\nusing RCall\nusing TidierData\nusing TDAmapper\n\ndf = R\"\"\"\nif (require(\"rrcov\") == FALSE) {\n    install.packages(\"rrcov\")\n}\n\nlibrary(rrcov)\ndata(\"diabetes\")\n\ndiabetes\n\"\"\" |&gt; rcopy;\n\n┌ Warning: RCall.jl: Carregando pacotes exigidos: rrcov\n│ Carregando pacotes exigidos: robustbase\n│ Scalable Robust Estimators with High Breakdown Point (version 1.7-4)\n│ \n└ @ RCall ~/.julia/packages/RCall/LWzAQ/src/io.jl:172\n\n\n\nfirst(df, 10)\n\n10×6 DataFrame\n\n\n\nRow\nrw\nfpg\nglucose\ninsulin\nsspg\ngroup\n\n\n\nFloat64\nInt64\nInt64\nInt64\nInt64\nCat…\n\n\n\n\n1\n0.81\n80\n356\n124\n55\nnormal\n\n\n2\n0.95\n97\n289\n117\n76\nnormal\n\n\n3\n0.94\n105\n319\n143\n105\nnormal\n\n\n4\n1.04\n90\n356\n199\n108\nnormal\n\n\n5\n1.0\n90\n323\n240\n143\nnormal\n\n\n6\n0.76\n86\n381\n157\n165\nnormal\n\n\n7\n0.91\n100\n350\n221\n119\nnormal\n\n\n8\n1.1\n85\n301\n186\n105\nnormal\n\n\n9\n0.99\n97\n379\n142\n98\nnormal\n\n\n10\n0.78\n97\n296\n131\n94\nnormal\n\n\n\n\n\n\nNow, let’s extract only the numeric columns\n\npre_X = @chain df begin\n    @select(rw, fpg, glucose, insulin, sspg)\n    Matrix    \n    end;\n\nand normalize them\n\nfunction normalize(x)\n    dev = std(x)\n    if (std(x) ≈ 0) \n        dev = 1\n    end\n\n    (x .- mean(x)) ./ dev\nend\n\nX = mapslices(normalize, pre_X, dims = 1)' |&gt; Matrix;"
  },
  {
    "objectID": "examples/diabetes.html#ball-mapper",
    "href": "examples/diabetes.html#ball-mapper",
    "title": "The Reaven and Miller diabetes dataset",
    "section": "Ball mapper",
    "text": "Ball mapper\nNow we calculate the ball mapper using all nodes, and setting \\(\\epsilon = 0.5\\):\n\nmp = ball_mapper(X, [1:size(X)[2];], ϵ = 0.5);\n\nThe resulting graph is the following\n\nnode_values = node_colors(mp, df.group .|&gt; string)\nnode_positions = layout_mds(mp.CX, dim = 3)\n\nmapper_plot(mp, node_values = node_values, node_positions = node_positions)\n\n\n\n\nWe colored each node by the most commom type of diabetes of the points in the node. We can see two branches coming from the center: one going left, with overt type diabetes, and another one going up, with chemical type diabetes."
  }
]